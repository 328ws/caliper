/**
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/

'use strict';

const fs = require('fs');
const Client = require('fabric-client');
<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
const e2eUtils = require('./e2eUtils.js');
=======

>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
const testUtil = require('./util.js');
const commUtils = require('../../comm/util');
const commlogger = commUtils.getLogger('join-channel.js');

<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
=======
//let the_user = null;
let tx_id = null;
let ORGS;
let isChannelEventHub = false;
const allEventhubs = [];

/**
 * Disconnect from the given list of event hubs.
 * @param {object[]} ehs A collection of event hubs.
 */
function disconnect(ehs) {
    for(let key in ehs) {
        const eventhub = ehs[key];
        if (eventhub && eventhub.isconnected()) {
            eventhub.disconnect();
        }
    }
}

>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
/**
 * Join the peers of the given organization to the given channel.
 * @param {string} org The name of the organization.
 * @param {string} channelName The name of the channel.
 * @param {object} orgs orgs from configuration details.
 * @async
 */
async function joinChannel(org, channelName, orgs) {
    const client = new Client();
    const channel = client.newChannel(channelName);
    const orgName = orgs[org].name;
    const targets = [];

<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
    const caRootsPath = orgs.orderer.tls_cacerts;
=======
    const orgName = ORGS[org].name;

    const targets = [], eventhubs = [];
    const eventPromises = [];

    const caRootsPath = ORGS.orderer.tls_cacerts;
>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
    let data = fs.readFileSync(commUtils.resolvePath(caRootsPath));
    let caroots = Buffer.from(data).toString();

    try {

        // Conditional action on TLS enablement
        if(orgs.orderer.url.toString().startsWith('grpcs')){
            const fabricCAEndpoint = orgs[org].ca.url;
            const caName = orgs[org].ca.name;
            const tlsInfo = await e2eUtils.tlsEnroll(fabricCAEndpoint, caName);
            client.setTlsClientCertAndKey(tlsInfo.certificate, tlsInfo.key);
        }

        const store = await Client.newDefaultKeyValueStore({path: testUtil.storePathForOrg(orgName)});
        client.setStateStore(store);
        await testUtil.getOrderAdminSubmitter(client);

        channel.addOrderer(
            client.newOrderer(
                orgs.orderer.url,
                {
                    'pem': caroots,
                    'ssl-target-name-override': orgs.orderer['server-hostname']
                }
            )
        );

        let tx_id = client.newTransactionID();
        let request = {
            txId : tx_id
        };

        const genesis_block = await channel.getGenesisBlock(request);

        // get the peer org's admin required to send join channel requests
        client._userContext = null;

        await testUtil.getSubmitter(client, true /* get peer org admin */, org);

<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
        for (let key in orgs[org]) {
            if (orgs[org].hasOwnProperty(key)) {
                if(key.indexOf('peer') === 0) {
                    data = fs.readFileSync(commUtils.resolvePath(orgs[org][key].tls_cacerts));
                    targets.push(
                        client.newPeer(
                            orgs[org][key].requests,
                            {
                                pem: Buffer.from(data).toString(),
                                'ssl-target-name-override': orgs[org][key]['server-hostname']
                            }
                        )
                    );
                }
=======
            data = fs.readFileSync(commUtils.resolvePath(ORGS[org][key].tls_cacerts));
            targets.push(
                client.newPeer(
                    ORGS[org][key].requests,
                    {
                        pem: Buffer.from(data).toString(),
                        'ssl-target-name-override': ORGS[org][key]['server-hostname']
                    }
                )
            );
            if (!isChannelEventHub) {
                const EventHub = require('fabric-client/lib/EventHub.js');
                let eh = new EventHub(client);
                eh.setPeerAddr(
                    ORGS[org][key].events,
                    {
                        pem: Buffer.from(data).toString(),
                        'ssl-target-name-override': ORGS[org][key]['server-hostname']
                    }
                );
                eh.connect();
                eventhubs.push(eh);
                allEventhubs.push(eh);
>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
            }
        }
        if (!isChannelEventHub) {
            eventhubs.forEach((eh) => {
                let txPromise = new Promise((resolve, reject) => {
                    let handle = setTimeout(reject, 30000);

<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
=======
                    eh.registerBlockEvent((block) => {
                        clearTimeout(handle);

                        // in real-world situations, a peer may have more than one channel so
                        // we must check that this block came from the channel we asked the peer to join
                        if(block.data.data.length === 1) {
                        // Config block must only contain one transaction
                            const channel_header = block.data.data[0].payload.header.channel_header;
                            if (channel_header.channel_id === channelName) {
                                resolve();
                            }
                            else {
                                reject(new Error('invalid channel name'));
                            }
                        }
                    });
                });

                eventPromises.push(txPromise);
            });
        }

>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
        tx_id = client.newTransactionID();
        request = {
            targets : targets,
            block : genesis_block,
            txId : tx_id
        };

        const results = await channel.joinChannel(request, 130000);

        if(results[0] && results[0].response && results[0].response.status === 200) {
            commlogger.info(`Successfully joined ${orgName}'s peers to ${channelName}`);
        } else {
            throw new Error('Unexpected join channel response: ' + JSON.stringify(results));
        }
    } catch (err) {
        commlogger.error(`Couldn't join ${orgName}'s peers to ${channelName}: ${err.stack ? err.stack : err}`);
        throw err;
    }
}

/**
 * Join the channel
 * @param {*} config_path The path to the Fabric network configuration file.
 * @async
 */
async function run(config_path) {
    const fabric = commUtils.parseYaml(config_path).fabric;
    const info = commUtils.parseYaml(config_path).info;
    let channels = fabric.channel;
    if(!channels || channels.length === 0) {
        return;
    }
<<<<<<< 7502380504ca7ba832974839e18e118af1909a14
    const orgs = fabric.network;
=======
    ORGS = fabric.network;
    if (info.Version === '1.3.0' || info.Version === '1.4.0') {
        isChannelEventHub = true;
    }
>>>>>>> Changes to support the latest fabric 1.4 release and maintain backward compatibility to 1.2 as well.
    commlogger.info('Joining channels...');

    try {
        for (let channel of channels) {
            if(channel.deployed) {
                continue;
            }

            for (let org of channel.organizations) {
                // NOTE: made the execution sequential for easier debugging
                commlogger.info(`Joining organization ${org} to channel ${channel.name}...`);
                await joinChannel(org, channel.name, orgs);
            }

            commlogger.info(`Successfully joined ${channel.name}`);
        }
    } catch (err) {
        commlogger.error(`Failed to join peers: ${(err.stack ? err.stack : err)}`);
        throw err;
    }
}

module.exports.run = run;